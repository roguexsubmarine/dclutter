#!/bin/bash  
# Bash script  

log(){
    local FILE=$1
    local TYPE=$2
    local NUM=$3

    mkdir -p "$TYPE"
    mv "$FILE" "$TYPE"

    echo -e "$NUM\t$TYPE\t:$FILE"
    
    #create LOG if not
    touch LOG_FILE
    echo -e "$NUM\t$FILE\t$(pwd)/\t$(pwd)/$TYPE/" >> LOG_FILE

}

image_sep(){
    echo "D-cluttering images"
    echo $(pwd)

    #create LOG_FILE if not
    touch LOG_FILE
    local line_num=1

    for FILE in $(pwd)/*;
    do
        
        local file=$(basename "$FILE")

        if [ -f "$file" ];
        then
           
            #check if image
            if file -b "$file" | grep -q 'image\|Image';
            then
                
                #JPEG (joint photogenic experts group)
                #also include .xcf files (used by gimp)
                if file -b "$file" | grep -q 'JPEG';
                then
                    log "$file" "JPEG" "$line_num"
                    ((line_num++))

                #PNG (Portable Network Graphics)
                elif file -b "$file" | grep -q 'PNG';
                then
                    log "$file" "PNG" "$line_num"
                    ((line_num++))

                #SVG (Scalable Vector Graphics)
                elif file -b "$file" | grep -q 'SVG';
                then
                    log "$file" "SVG" "$line_num"
                    ((line_num++))
                
                #.ai
                elif file -b "$file" | grep -q 'Adobe Photoshop';
                then
                    log "$file" "Adobe" "$line_num"
                    ((line_num++))
                
                #TIFF (Tagged Image File Format)
                elif file -b "$file" | grep -q 'TIFF';
                then
                    log "$file" "TIFF" "$line_num"
                    ((line_num++))
                
                #HEIF (High Efficiency Image File)
                elif file -b "$file" | grep -q 'HEIF';
                then
                    log "$file" "HEIF" "$line_num"
                    ((line_num++))

                elif file -b "$file" | grep -q 'Web/P';
                then
                    log "$file" "WEBP" "$line_num"
                    ((line_num++))
                
                #GIF (Graphics Interchange Format)
                elif file -b "$file" | grep -q 'GIF';
                then
                    log "$file" "GIF" "$line_num"
                    ((line_num++))

                elif file -b "$file" | grep -q 'Netpbm';
                then
                    log "$file" "PPM" "$line_num"
                    ((line_num++))

                fi


            elif file -b "$file" | grep -q 'PostScript';
            then
                log "$file" "EPS" "$line_num"
                ((line_num++))
            
            elif file -b "$file" | grep -q 'bitmap';
            then
                log "$file" "BITMAP" "$line_num"
                ((line_num++))
            fi

        fi

    done
}


remove_empty(){
    echo "D-eleting empty directories"
    echo $(pwd)

    local NUM=1

    for file in $(pwd)/*;
    do
        if [ -d "$file" ];
        then
            if [ $(ls -A "$file" | wc -l)  -eq 0 ];
            then
                echo -e "$NUM\tDeleting\t:$file"
                rmdir "$file"
                ((NUM++))
            fi
        fi
    done
}


dclutter_main(){
    echo "D-cluttering current working directory..."
    echo $(pwd)

    #create LOG_FILE if not
    touch LOG_FILE
    local line_num=1

    for FILE in "$(pwd)"/*;
    do

        local file=$(basename "$FILE")
    
        if [ -f "$file" ];
        then

        
            #RECENT
            #check if file is modified within last hour
            if [ "$(find "$file" -mmin -60 2>/dev/null)" ];
            then
                mkdir -p recent
                cp "$file" recent
                echo -e "recent\t:$file" 
            fi

            #CATEGORIZING
       
            #check for images
            if file -b "$file" | grep -q 'image\|Image\|PostScript\|bitmap';
            then
                log "$file" "images" "$line_num"
                ((line_num++))
          
            #check for documents
            elif file -b "$file" | grep -q 'document';
            then
                log "$file" "documents" "$line_num"
                ((line_num++))
        
            #check for compression
            elif file -b "$file" | grep -q 'compress';
            then
                log "$file" "compressed" "$line_num"
                ((line_num++))

            #check for ASCII/text/code
            elif file -b "$file" | grep -q 'ASCII\|text\|JSON';
            then
                log "$file" "codext" "$line_num"
                ((line_num++))
                 mkdir -p codext
     
            #check for binaries or src code
            elif file -b "$file" | grep -q 'bin\|src';
            then
                log "$file" "src_bin" "$line_num"
                ((line_num++))
           
            #check for audio
            elif file -b "$file" | grep -q 'Audio';
            then
                log "$file" "audio" "$line_num"
                ((line_num++))

            #check for videos (no choice fo this one... check extensions)
            elif [[ "$file" == *.mp4 || "$file" == *.mkv ]];
            then
                log "$file" "video" "$line_num"
                ((line_num++))

            #check for fonts
            elif file -b "$file" | grep -q "Font";
            then
                log "$file" "font" "$line_num"
                ((line_num++))
 
            #check for iso images
            elif file -b "$file" | grep -q 'bootable';
            then
                log "$file" "bootables" "$line_num"
                ((line_num++))

            #check for microsoft files
            elif file -b "$file" | grep -q 'Microsoft';
            then
                log "$file" "microsoft" "$line_num"
                ((line_num++))

            fi
        fi
    done
}




# if no options provided
if [ $# -eq 0 ];
then
    dclutter_main
else

    #check for options
    if [ "$1" == '-c' ];
    then
        remove_empty
        exit 0
    elif [ "$1" == '-i' ];
    then
        image_sep
        exit 0
    fi

fi
